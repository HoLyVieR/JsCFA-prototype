eval (f@FunctionExpr(name, paras, body), env) =
  let closure = Closure(f, env)
  let funcObject = scalaCall(createFunctionObject,[closure])
  functionObject

eval (Infix(op, e1, e2), env) =
  let v1 = eval(e1)
  let v2 = eval(e2)
  do v11 <- getValue(v1)
     v22 <- getValue(v2)
     return infixFunction(op, v1, v2)

eval (Infix(op, e1, e2), env, lk, gk) =
  eval(e1, env, fn(v1, env, lk, gk) {
    eval(e2, env, fn(v2, env, lk, gk) {
      do v11 <- getValue(v1)
         v22 <- getValue(v2)
         lk(infixFunction(op, v1, v2))
    }, gk)
  },gk)

teval (Infix(op, e1, e2), env, lk, gk) = tcont(e1, env, newlk, gk)

Infix => InfixL => InfixR => InfixComplete

eval (NumberLit(n)) =
  let v = JSNumber(Constant(n))
  let add = save(v)
  add

eval (FuncCall(f, arguments), env) =
  let funcRef = eval(f)
  let args = eval(arguments) //each one
  do func <- getValue(funcRef)
     if isCallable(func)
     funcObject = ToObject(func)
     return {
        val decompose Closure(FunctionExpr(name, paras, body), savedEnv) = funcObject.code
        ....
        saveEnv()
        pushStack()
        eval(body, newEnv)
     }

eval (ListExpr(exprs)) =
  match exprs {
    e :: Nil => eval(e)
    e :: es =>
      let _ = eval(e)
      eval(ListExpr(List(es)))
  }

eval (ObjectLit(Nil)) =
